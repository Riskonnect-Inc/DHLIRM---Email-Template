/*! Riskonnect Modules JS Frameworks - BlockChart - v0.0.1 - 2017-12-08
* Copyright (c) 2017 Jason Bradley; Licensed Commercial */
/***********************************************************
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Make changes in the stash project: 
 *    https://rksource01.riskonnect.com/stash/scm/~jason.bradley_riskonnect.com/blockchart.git
 * And upload the aggregated dist file that will replace 
 * this file.
 *
 ***********************************************************/


;(function() {
    "use strict";

    window.namespace_exists = window.namespace_exists || function(nmspc) {
        var ret = window;
        nmspc.split('.').forEach(function(name) {
            ret = ret ? ret[name] || false : ret;
        });

        return ret !== false && Object.keys(ret).length > 0;
    };

    window.namespace = window.namespace || function(nmspc) {
        var space = window;
        nmspc.split('.').forEach(function(name) {
            space = space[name] = space[name] || {};
        });

        return space;
    };

    window.conthunktor = window.conthunktor || function(func, args) {
        var ReflectedObject = function(){};
        ReflectedObject.prototype = func.prototype;
        var inst = new ReflectedObject();
        var ret = func.apply(inst, args);
        ret = (Object(ret) === ret) ? ret : inst;
        return ret;
    };

})();

/* global kendo: false */
;(function($) {
    "use strict";
    
    var api = namespace("rkl.blockchart.utils");

    var kGeom = kendo.geometry,
    	kDraw = kendo.drawing,
    	kThemes = kendo.dataviz.ui.themes;

    //Pulled from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Polyfill
    Array.prototype.map = Array.prototype.map || function(callback) {
        var T, A, k;
        if (this === null) {
            throw new TypeError("this is null or not defined");
        }
        var O = Object(this);
        var len = O.length >>> 0;
        if (typeof callback !== "function") {
            throw new TypeError(callback + " is not a function");
        }
        if (arguments.length > 1) {
            T = arguments[1];
        }
        A = new Array(len);
        k = 0;
        while (k < len) {
            var kValue, mappedValue;
            if (k in O) {
                kValue = O[k];
                mappedValue = callback.call(T, kValue, k, O);
                A[k] = mappedValue;
            }
            k++;
        }
        return A;
    };

    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	if (!Array.prototype.findIndex) {
	  Object.defineProperty(Array.prototype, 'findIndex', {
	    value: function(predicate) {
	     // 1. Let O be ? ToObject(this value).
	      if (this === null) {
	        throw new TypeError('"this" is null or not defined');
	      }

	      var o = Object(this);

	      // 2. Let len be ? ToLength(? Get(O, "length")).
	      var len = o.length >>> 0;

	      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
	      if (typeof predicate !== 'function') {
	        throw new TypeError('predicate must be a function');
	      }

	      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
	      var thisArg = arguments[1];

	      // 5. Let k be 0.
	      var k = 0;

	      // 6. Repeat, while k < len
	      while (k < len) {
	        // a. Let Pk be ! ToString(k).
	        // b. Let kValue be ? Get(O, Pk).
	        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
	        // d. If testResult is true, return k.
	        var kValue = o[k];
	        if (predicate.call(thisArg, kValue, k, o)) {
	          return k;
	        }
	        // e. Increase k by 1.
	        k++;
	      }

	      // 7. Return -1.
	      return -1;
	    }
	  });
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.18
	// Reference: http://es5.github.io/#x15.4.4.18
	if (!Array.prototype.forEach) {

	  Array.prototype.forEach = function(callback/*, thisArg*/) {

	    var T, k;

	    if (this === null) {
	      throw new TypeError('this is null or not defined');
	    }

	    // 1. Let O be the result of calling toObject() passing the
	    // |this| value as the argument.
	    var O = Object(this);

	    // 2. Let lenValue be the result of calling the Get() internal
	    // method of O with the argument "length".
	    // 3. Let len be toUint32(lenValue).
	    var len = O.length >>> 0;

	    // 4. If isCallable(callback) is false, throw a TypeError exception. 
	    // See: http://es5.github.com/#x9.11
	    if (typeof callback !== 'function') {
	      throw new TypeError(callback + ' is not a function');
	    }

	    // 5. If thisArg was supplied, let T be thisArg; else let
	    // T be undefined.
	    if (arguments.length > 1) {
	      T = arguments[1];
	    }

	    // 6. Let k be 0.
	    k = 0;

	    // 7. Repeat while k < len.
	    while (k < len) {

	      var kValue;

	      // a. Let Pk be ToString(k).
	      //    This is implicit for LHS operands of the in operator.
	      // b. Let kPresent be the result of calling the HasProperty
	      //    internal method of O with argument Pk.
	      //    This step can be combined with c.
	      // c. If kPresent is true, then
	      if (k in O) {

	        // i. Let kValue be the result of calling the Get internal
	        // method of O with argument Pk.
	        kValue = O[k];

	        // ii. Call the Call internal method of callback with T as
	        // the this value and argument list containing kValue, k, and O.
	        callback.call(T, kValue, k, O);
	      }
	      // d. Increase k by 1.
	      k++;
	    }
	    // 8. return undefined.
	  };
	}

	function midpoint(lowerBound, upperBound) {
		return (upperBound - lowerBound) / 2.0;
	}
	api.midpoint = midpoint;

    function incrementInterval(intervalValue,intervalSize,scale,iteration,lowerBound){
		if(scale === 'linear'){
			intervalValue += intervalSize;
		}
		else if(scale === 'logarithmic'){
			//going for base 10 log
			intervalValue *= 10;
			//handle case where intervalValue was initially 0;
			if(intervalValue === 0){
				intervalValue = 10;
			}
		}
		else if(scale === 'cubic'){
			intervalValue = (iteration*iteration*iteration) + lowerBound;
		}
		return intervalValue;
	}

    function generateIntervals(lowerBound, upperBound, numIntervals, skipFirst, skipLast, scale) {
    	numIntervals = Math.floor(numIntervals);
		var intervalSize = (upperBound - lowerBound) / numIntervals;
        var intervals = [];
		var intervalValue = lowerBound;
		var iteration = 0;
		//default the scale to linear, if not provided, or a bad value
		if(!scale || ["linear","logarithmic","cubic"].indexOf(scale) === -1){
			scale = "linear";
		}
        if (skipFirst) {
        	intervalValue = incrementInterval(intervalValue,intervalSize,scale);
			numIntervals--;
			iteration++;
        }
        if (skipLast) {
        	numIntervals--;
		}
        while (intervals.length <= numIntervals) {
			intervals.push(intervalValue);
			intervalValue = incrementInterval(intervalValue,intervalSize,scale,iteration,lowerBound);
			iteration++;
        }
        return intervals;
    }
    api.generateIntervals = generateIntervals;

    function generateScale(lowerBound, upperBound, numIntervals) {
    	numIntervals = Math.floor(numIntervals);
    	var intervalSize = (upperBound - lowerBound) / numIntervals;
    	var scaleValues = [];
    	for (var i = 0; i < numIntervals; i++) {
    		scaleValues.push(i * intervalSize + lowerBound);
    	}
    	return scaleValues;
    }
    api.generateScale = generateScale;

    /*
    	Description: Generates a CSS font string from a parameterized config object

    	Input: fontConfig: {
    		style: <STRING>,
    		variant: <STRING>,
    		weight: <STRING>,
    		stretch: <STRING>,
    		size: <INT>,
    		sizeUnits: <STRING>,
    		lineHeight: <INT>,
    		family: <STRING> || <ARRAY>
    	}

    	Output: "<style> <variant> <weight> <stretch> <size><sizeUnits>/<lineHeight> <family>"
    			 normal normal bold normal 12pxpt/normal Arial, Helvetica, sans-serif
    */
    var fontSizeRegex = /([0-9\.]+)(.*)/ig;
    function generateFontString(fontConfig, overrideConfig) {
    	if (typeof fontConfig !== "object") {
	    	if (!overrideConfig) {
	    		return fontConfig;
	    	} else {
	    		fontConfig = parseFontString(fontConfig);
	    	}
    	}

        var fontParts = [];
        if (overrideConfig) {
            fontConfig = kendo.deepExtend({}, fontConfig, overrideConfig);
        }
        if (fontConfig.style) {
            fontParts.push(fontConfig.style);
        }
        if (fontConfig.variant) {
            fontParts.push(fontConfig.variant);
        }
        if (fontConfig.weight) {
            fontParts.push(fontConfig.weight);
        }
        if (fontConfig.stretch) {
            fontParts.push(fontConfig.stretch);
        }
        if (fontConfig.size) {
        	var fontSize = "" + fontConfig.size;
        	var fontUnits;
        	fontSizeRegex.lastIndex = 0;
        	var fontSizeParts = fontSizeRegex.exec(fontSize);
        	if (fontSizeParts && fontSizeParts.length > 1) {
        		fontSize = fontSizeParts[1];
        		fontUnits = fontSizeParts[2];
        	}
        	fontUnits = fontConfig.sizeUnits || fontUnits || "pt";

        	//TODO: Check if units already in font size
        	fontParts.push(fontSize + fontUnits + (fontConfig.lineHeight ? "/" + fontConfig.lineHeight : ""));
        } else {
            fontParts.push("18pt");
        }
        if (fontConfig.family) {
            fontParts.push(Array.isArray(fontConfig.family) ? fontConfig.family.join(", ") : fontConfig.family);
        } else {
            fontParts.push("arial");
        }
        return fontParts.join(" ");
    }
    api.generateFontString = generateFontString;

    function parseFontString(cssFontString) {
    	var tempElem = document.createElement("div");
    	tempElem.style.font = cssFontString;

    	return {
    		style: tempElem.style.fontStyle || "normal",
    		variant: tempElem.style.fontVariant || "normal",
    		weight: tempElem.style.fontWeight || "normal",
    		stretch: tempElem.style.fontStretch,
    		size: tempElem.style.fontSize,
    		lineHeight: tempElem.style.lineHeight,
    		family: tempElem.style.fontFamily
    	};
    }
    api.parseFontString = parseFontString;

    function generateText(content, x, y, fontConfig, fontColor, horizontalAlignment, verticalAlignment) {
		var newText;
		if (content instanceof kDraw.Text) {
			newText = content;
			newText.position([x, y]);
			newText.options.set("font", generateFontString(fontConfig));
			newText.fill(fontColor || newText.fill() || "black", 1);
			newText.transform(kGeom.transform());
		} else {
			newText = new kDraw.Text("" + content, new kGeom.Point(x, y), {
				fill: {
					color: fontColor || "black",
					opacity: 1
				},
				font: generateFontString(fontConfig)
			});
		}

		applyAlignmentToText(newText, horizontalAlignment, verticalAlignment);

		return newText;
	}
	api.generateText = generateText;

    function applyAlignmentToText(text, horizontalAlignment, verticalAlignment) {
    	horizontalAlignment = horizontalAlignment || text._horizontalAlignment;
    	verticalAlignment = verticalAlignment || text._verticalAlignment;

    	if (horizontalAlignment || verticalAlignment) {
    		//var textTransform = text.transform() || kGeom.transform();
    		var textTransform = kGeom.transform();
    		text.transform(textTransform);

    		text._horizontalAlignment = horizontalAlignment;
    		text._verticalAlignment = verticalAlignment;

    		var bbox = text.bbox();
    		var xTransform = 0, yTransform = 0;

    		if (horizontalAlignment === "center") {
    			xTransform = -bbox.size.width / 2;
    		} else if (horizontalAlignment === "right") {
    			xTransform = -bbox.size.width;
    		}

    		if (verticalAlignment === "center") {
    			yTransform = -bbox.size.height / 2;
    		} else if (verticalAlignment === "bottom") {
    			yTransform = -bbox.size.height;
    		}

    		textTransform.translate(xTransform, yTransform);
    	}
    }
    api.applyAlignmentToText = applyAlignmentToText;

	function generatePath(startX, startY, endX, endY, existingPath) {
		var width = endX - startX,
			height = endY - startY;

		var pathPoints = [
			[startX, startY],
			[startX + width / 2, startY],
			[startX + width / 2, endY],
			[endX, endY]
		];

		if (existingPath) {
			pathPoints.forEach(function(point, i) {
				existingPath.segments[i].anchor().setX(point[0]);
				existingPath.segments[i].anchor().setY(point[1]);
			});
			return existingPath;
		} else {
			return kDraw.Path.fromPoints(pathPoints);
		}
	}
	api.generatePath = generatePath;

	function calcTextVsBoxDimensions(text, rect) {
		var textBBox = text.bbox(),
			rectBBox = rect.bbox ? rect.bbox() : rect,
			textWidth = textBBox.size.width,
			textHeight = textBBox.size.height,
			rectWidth = rectBBox.size.width,
			rectHeight = rectBBox.size.height,
			sizeRatio_H_H = textHeight / (rectHeight * 0.35),
			sizeRatio_H_W = textWidth / rectWidth,
			sizeRatio_V_H = textWidth / rectHeight,
			sizeRatio_V_W = textHeight / (rectWidth * 0.35);

		return {
			textWidth: textWidth,
			textHeight: textHeight,
			rectWidth: rectWidth,
			rectHeight: rectHeight,
			sizeRatio_H_W: sizeRatio_H_W,
			sizeRatio_H_H: sizeRatio_H_H,
			sizeRatio_V_H: sizeRatio_V_H,
			sizeRatio_V_W: sizeRatio_V_W,
			textRescaleAmount_H_H: 1 / sizeRatio_H_H,
			textRescaleAmount_H_W: 1 / sizeRatio_H_W,
			textRescaleAmount_V_H: 1 / sizeRatio_V_H,
			textRescaleAmount_V_W: 1 / sizeRatio_V_W,
			rectRatio: rectWidth / rectHeight
		};
	}

	function fitText(layout, rect, text, originalFontSize, minimumFontSize, font) {
		var textTransform = kGeom.transform();
		textTransform.rotate(0);
		text.transform(textTransform);

		//Reset font size before determining resize amounts
		text.options.set("font", generateFontString(font, { size: originalFontSize }));

		if (layout) {
			layout.rect(rect.geometry());
			layout.reflow();
		}

		var ratio_W, ratio_H, rescale_W, rescale_H;
		var shouldBeVertical = false;

		var textComparisonResults = calcTextVsBoxDimensions(text, rect);

		//Determine if text should be vertically or horizontally oriented
		if (textComparisonResults.rectRatio >= 0.5) {
			//Should be horizontally oriented
			ratio_W = "sizeRatio_H_W";
			ratio_H = "sizeRatio_H_H";
			rescale_W = "textRescaleAmount_H_W";
			rescale_H = "textRescaleAmount_H_H";
		} else {
			//Should be vertically oriented
			ratio_W = "sizeRatio_V_H";
			ratio_H = "sizeRatio_V_W";
			rescale_W = "textRescaleAmount_V_H";
			rescale_H = "textRescaleAmount_V_W";

			shouldBeVertical = true;
		}

		//Check if the font size should be decreased to fit within the containing rectangle
		if (textComparisonResults[ratio_H] > 1.0 || textComparisonResults[ratio_W] > 1.0) {
			var newFontSize = originalFontSize * textComparisonResults[rescale_H];
			newFontSize = Math.min(Math.max(newFontSize, minimumFontSize), originalFontSize);
			text.options.set("font", generateFontString(font, { size: newFontSize }));

			//Determine if the text needs to be trimmed to fit
			textComparisonResults = calcTextVsBoxDimensions(text, rect);

			if (textComparisonResults[ratio_W] > 1.0) {
				var originalText = text.content();
				var newText = originalText.substring(0, originalText.length * textComparisonResults[rescale_W] - 3) + "...";
				text.content(newText);
			}
		}

		if (shouldBeVertical) {
			textTransform.rotate(-90);
		}

		if (layout) {
			layout.reflow();
		}

		applyAlignmentToText(text);
	}
	api.fitText = fitText;

	var skipPortion = 0.15;
	var lastPickedColor;
	function colorPicker(palette) {
		var pickedColor = lastPickedColor;
		while (pickedColor === lastPickedColor) {
			if (palette) {
				pickedColor = palette[Math.floor(Math.random() * palette.length)];
			} else {
				var r = parseInt((Math.random() * 255 * (1.0 - skipPortion) + 255 * skipPortion).toFixed(0)),
					g = parseInt((Math.random() * 255 * (1.0 - skipPortion) + 255 * skipPortion).toFixed(0)),
					b = parseInt((Math.random() * 255 * (1.0 - skipPortion) + 255 * skipPortion).toFixed(0));

				pickedColor = "#" + r.toString(16) + g.toString(16) + b.toString(16);
			}
		}
		return pickedColor;
	}
	api.colorPicker = colorPicker;

	function generateContrastingColor(color) {
		if (color.startsWith("#")) {
			color = color.substring(1);
		}

		var rgb = [
			parseInt(color.substring(0, 2), 16),
			parseInt(color.substring(2, 4), 16),
			parseInt(color.substring(4, 6), 16)
		];

		//https://www.w3.org/TR/AERT/#color-contrast
		var brightness = ((rgb[0] * 299) + (rgb[1] * 587) + rgb[2] * 114) / 1000;
		if (brightness > 125) {
			return "#000";
		} else {
			return "#efefef";
		}
	}
	api.generateContrastingColor = generateContrastingColor;

	function lightenColor(color, lightenAmount) {
		if (color.startsWith("#")) {
			color = color.substring(1);
		}

		var rgb = [
			Math.floor(Math.min(255, parseInt(color.substring(0, 2), 16) + 255 * lightenAmount)),
			Math.floor(Math.min(255, parseInt(color.substring(2, 4), 16) + 255 * lightenAmount)),
			Math.floor(Math.min(255, parseInt(color.substring(4, 6), 16) + 255 * lightenAmount))
		];

		return "#" + rgb[0].toString(16) + rgb[1].toString(16) + rgb[2].toString(16);
	}
	api.lightenColor = lightenColor;

	var themeNamePattern = /kendo\.common-([^\.]+)(?:\.min)?\.css$/;
	function getCurrentTheme() {
		var currentStylesheets = document.getElementsByTagName("link");
		for (var i = 0; i < currentStylesheets.length; i++) {
			var hrefMatches = themeNamePattern.exec(currentStylesheets[i].href);
			if (hrefMatches) {
				return hrefMatches[1];
			}
		}
	}
	api.getCurrentTheme = getCurrentTheme;

	function clampToHalfPixel(val) {
		return Math.floor(val) + 0.5;
	}
	api.clampToHalfPixel = clampToHalfPixel;

	function findNearestMultiple(value, multipleBase, additionalExplicitBoundaries) {
		var defaultSnapValues = [Math.ceil(value / multipleBase) * multipleBase, Math.floor(value / multipleBase) * multipleBase];
		var snapValues = [];

		if (additionalExplicitBoundaries && additionalExplicitBoundaries.length) {
			additionalExplicitBoundaries = additionalExplicitBoundaries.slice().sort();

			snapValues = snapValues.concat(additionalExplicitBoundaries);
			
			var fullDataRange = additionalExplicitBoundaries[additionalExplicitBoundaries.length - 1] - additionalExplicitBoundaries[0];
			defaultSnapValues.forEach(function(defaultSnapValue) {
				var isTooClose = false;
				additionalExplicitBoundaries.forEach(function(snapValue) {
					if ((Math.abs(defaultSnapValue - snapValue) / fullDataRange) < 0.05) {
						isTooClose = true;
					}
				});

				if (!isTooClose) {
					snapValues = snapValues.concat(defaultSnapValue);
				}
			});
		} else {
			snapValues = defaultSnapValues;
		}

		var closestSnapValue, closestDistance = Infinity;
		snapValues.forEach(function(snapValue) {
			var snapDistance = Math.abs(snapValue - value);
			if (snapDistance < closestDistance) {
				closestDistance = snapDistance;
				closestSnapValue = snapValue;
			}
		});
		return closestSnapValue;
	}
	api.findNearestMultiple = findNearestMultiple;

	function getStringArray_N(obj, getField, defaultValue, setField) {
		var data = obj[setField || getField] || obj[getField];
		if (typeof data === "string") {
			if (data) {
				data = obj[setField || getField] = data.split(",");
			} else {
				data = obj[setField || getField] = defaultValue;
			}
		} else if (!data) {
			data = obj[setField || getField] = defaultValue;
		}
		return data;
	}
	api.getStringArray_N = getStringArray_N;

	function cleanKendoFieldName(field) {
		return field.replace(/[ \/\&]/g, '');
	}
	api.cleanKendoFieldName = cleanKendoFieldName;

	function unicodeEscapeString(str) {
		return str.replace(/[\S\s]/g, function(ch) {
	        return "\\u" + ("000" + ch.charCodeAt().toString(16)).slice(-4);
	    });
	}
	api.unicodeEscapeString = unicodeEscapeString;
})(jQuery);
;(function($) {
    "use strict";

    var api = namespace('rkl.blockchart'),
    	_ = namespace('rkl.blockchart.utils');

    var kGeom = kendo.geometry,
    	kDraw = kendo.drawing,
    	kThemes = kendo.dataviz.ui.themes,
		Widget = kendo.ui.Widget;

	var widgetName = "BlockChart",
		widgetJQName = "kendo" + widgetName;

	var E_CHANGE = "change",
		E_DATABINDING = "dataBinding",
		E_DATABOUND = "dataBound",
		E_CHANGEBOUND = "changeBounds";

	var P_DATA = "_blockChart",
		P_CATGS = "_catgs",
		P_GEOM = "_geom",
		P_RECT = "_rect",
		P_LAYOUT = "_layout",
		P_TEXT = "_text",
		P_HASBUILT = "_built";

	var _clickMod = 1, _mouseEnterMod = 1, _mouseLeaveMod = 1, _mouseUpMod = 1, _mouseDownMod = 1, _mouseMoveMod = 1;

    //=============== BLOCKCHART IMPLEMENTATION ===============
	var BlockChart = Widget.extend({
		init: function(element, options) {
			var that = this;
			
			kendo.destroy(element);
			Widget.fn.init.call(that, element, options);

			//Apply any user specified option overrides
			that._originalOptions = kendo.deepExtend({}, that.options);
			that.setOptions(options);

			that._chartContainer = element;

			that._$readyDef = $.Deferred();
			that._$ready = that._$readyDef.promise();

			//Blocks any "init" methods from firing more than once
			that._hasDOMInit = false;
			that._hasDrawInit = false;
			that._hasInitResize = false;

			that._colorIdx = 0;
			that._allCategoriesMap = {};

			that._boundsOverride = {
				xLower: null,
				xUpper: null,
				yLower: null,
				yUpper: null
			};

			that._fitMode = false;

			//Logic locking flags - Used to keep the chart up to date with the datasource, without causing infinite change handler loops
			that._needsRecalc = true;
			that._recalcInProgress = false;
			that._needsRedraw = true;
			that._haveIntervalsBeenEdited = false;
			that._haveIntervalsChanged = false;

			//Sets up the draw surface, and any basic elements needed by the visualization
			that._initDraw();

			//Grabs a reference to the SVG created by kendo.Surface - Used for any manual element-level tweaking
			that._initDOM();

			//Initializes the page-resize handler - Resizes the graph to fit within the page, as long as it fits within all data-level size constraints
			that._initResizeHandler();
			that._rescaleApplied = false;
		},
		setDataSource: function(dataSource) {
			//Swap out the current data source for the newly specified one, and re-initialize
			this.options.dataSource = dataSource;
			this._dataSource();
		},
		_dataSource: function() {
			var that = this;

			if (that.dataSource) {
				that.dataSource.unbind("change");
			}

			//Create a new DataSource instance using the current dataSource (using DataSource.create allows for flexibility in the input format for the DataSource)
			that.dataSource = kendo.data.DataSource.create(that.options.dataSource);

			that.dataSource.bind("change", function(e) {
				if (e.action === "add" || e.action === "remove") {
					that.refresh();
				}
			});

			//Configure aggregate calculations for the DataSource
			that._configureAggregates();

			if (that.options.autoBind) {
				that.dataSource.fetch();
			}

			this.refresh();
		},
		_configureAggregates: function() {
			var that = this;

			var aggregateConfig = that.dataSource.aggregate() || [];

			aggregateConfig.push({
				field: that.options.fields.xLower,
				aggregate: "min"
			});

			aggregateConfig.push({
				field: that.options.fields.xUpper,
				aggregate: "max"
			});

			aggregateConfig.push({
				field: that.options.fields.yLower,
				aggregate: "min"
			});

			aggregateConfig.push({
				field: that.options.fields.yUpper,
				aggregate: "max"
			});

			that.dataSource.aggregate(aggregateConfig);
		},
		_setColors: function(items) {
			return kendo.dataviz.ui.TreeMap.prototype._setColors.call(this, items);
		},
		items: function() {
			return $();
		},
		refresh: function() {
			var that = this;

			if (that._hasDOMInit && that._hasDrawInit) {
				that.trigger(E_DATABINDING);

				that._needsRecalc = true;
				that._needsRedraw = true;
				that._draw();

				that.trigger(E_DATABOUND);
			}
		},
		_recalc: function() {
			var that = this;

			if (that._needsRecalc) {
				that._recalcInProgress = true;

				//=== Recalc data bounds ===
				var dataSourceAggregates = that.dataSource.aggregates();
				that._bounds = {};
				that._bounds[that.options.fields.xUpper] = that._boundsOverride.xUpper || dataSourceAggregates[that.options.fields.xUpper].max;
				that._bounds[that.options.fields.xLower] = that._boundsOverride.xLower || 0;
				that._bounds[that.options.fields.yLower] = that._boundsOverride.yLower || dataSourceAggregates[that.options.fields.yLower].min;
				that._bounds[that.options.fields.yUpper] = that._boundsOverride.yUpper || dataSourceAggregates[that.options.fields.yUpper].max;

				that._$evts.trigger(E_CHANGEBOUND, [that._bounds]);

				if (that._bounds[that.options.fields.xUpper] !== 0 ||
					that._bounds[that.options.fields.xLower] !== 0 || 
					that._bounds[that.options.fields.yLower] !== 0 || 
					that._bounds[that.options.fields.yUpper] !== 0) {
					that._$readyDef.resolve();
				}

				that._drawGroup_Text.clear();
				that._drawGroup_BG.clear();
				that._drawGroup_Chart.clear();
				that._drawGroup_Chart_PreOrder.clear();

				that._backgroundRect = new kDraw.Rect(new kGeom.Rect([that._OVtoS_x(0), that._OVtoS_y(0)], [that._OVtoS_x(1), that._OVtoS_y(1)]), {
					fill: {
						color: that.options.backgroundColor,
						opacity: 1
					}
				});
				that._backgroundRect._isBackground = true;
				that._drawGroup_BG.append(that._backgroundRect);

				that._titleText = _.generateText(that._titleText || that.options.title.text,
					that._VtoS_x(0.5),
					that._VtoS_y(0.0) - that.options.innerPadding.top / 2,
					that.options.title.font,
					"black",
					"center", "center"
				);
				that._drawGroup_Text.append(that._titleText);



				that._lowerBoundText = _.generateText(that._lowerBoundText || that._lowerBoundValue,
					that._VtoS_x(1.0) + that.options.hoverIntervalSpacing,
					that._VtoS_y(1.0),
					that.options.axisDefaults.labels.font,
					"black",
					"left", "center"
				);
				that._lowerBoundText.visible(false);
				that._drawGroup_Text.append(that._lowerBoundText);

				that._lowerBoundPath = _.generatePath(
					0, 0, 0, 0, that._lowerBoundPath
				);
				that._drawGroup_Text.append(that._lowerBoundPath);



				that._upperBoundText = _.generateText(that._upperBoundText || that._upperBoundValue,
					that._VtoS_x(1.0) + that.options.hoverIntervalSpacing,
					that._VtoS_y(0.0),
					that.options.axisDefaults.labels.font,
					"black",
					"left", "center"
				);
				that._upperBoundText.visible(false);
				that._drawGroup_Text.append(that._upperBoundText);

				that._upperBoundPath = _.generatePath(
					0, 0, 0, 0, that._upperBoundPath
				);
				that._drawGroup_Text.append(that._upperBoundPath);



				if (!that.dataSource.total()) {
					var chartEmptyText = _.generateText("No data to show.",
						that._VtoS_x(0.5),
						that._VtoS_y(0.5),
						that.options.font,
						"black",
						"center", "center");

					that._drawGroup_Text.append(chartEmptyText);

					that._needsRecalc = false;
					that._draw();
				} else {
					that._recalcCategories();
					that._calcDataBoundaries();

					//===== Recalc row rectangle dimensions =====
					var rowHandler;
					that.dataSource.data().forEach(rowHandler = function(rowData) {
						//Build private storage within row data for visualization data
						var blockChartData = rowData[P_DATA];
						if (!blockChartData) {
							blockChartData = rowData[P_DATA] = {};
						}

						//Normalize data values in the "category" field
						var rowCategories = _.getStringArray_N(rowData, that.options.fields.category, ["default"], "_category");

						//Handle each instance of the data row for each category it applies to
						var rowGeom = blockChartData[P_GEOM];
						if (!rowGeom) {
							rowGeom = blockChartData[P_GEOM] = new kGeom.Rect();
							rowGeom._recordId = rowData.id;
						}

						//kendo.drawing.Rect cache
						var rowRect = blockChartData[P_RECT];
						if (!rowRect) {
							//Build rectangle visual for row data
							rowRect = blockChartData[P_RECT] = new kDraw.Rect(rowGeom, {
								cursor: "pointer"
							});
							rowRect.stroke("black", that.options.strokeSize);
							rowRect._recordId = rowData.id;
						}

						//kendo.drawing.Layout cache
						var rowLayout = blockChartData[P_LAYOUT];
						if (!rowLayout) {
							//Build text layout visual for row data
							rowLayout = blockChartData[P_LAYOUT] = new kDraw.Layout(rowGeom, {
								alignContent: rowData.get(that.options.fields.textAlignV) || "center",
								justifyContent: rowData.get(that.options.fields.textAlignH) || "center",
								wrap: true,
								cursor: "pointer"
							});
							rowLayout._recordId = rowData.id;
						}

						//kendo.drawing.Text cache
						var rowText = blockChartData[P_TEXT];
						if (!rowText) {
							var textValue;
							if (typeof that.options.fields.text === "function") {
								textValue = that.options.fields.text.call(that, rowData);
							} else {
								textValue = rowData.get(that.options.fields.text);
							}
							rowText = blockChartData[P_TEXT] = _.generateText(textValue, 0, 0, that.options.font);

							//rowText.fill("black");
							rowText.fill(_.generateContrastingColor(rowData.get(that.options.fields.color)));
							rowText.options.set("cursor", "pointer");
							rowLayout.append(rowText);
							rowText._recordId = rowData.id;
							rowLayout._recordId = rowData.id;
						}

						that._drawGroup_Chart_PreOrder.append(rowRect);
						that._drawGroup_Text.append(rowLayout);

						//Set row-level change handler
						rowData.one(E_CHANGE, that._rowChangeHandler.bind(that));

						if (rowData.get(that.options.fields.children)) {
							rowData.get(that.options.fields.children).forEach(rowHandler);
						}

						rowData.trigger(E_CHANGE);
					});

					//Normalize draw order of blocks in visualization
					that._drawGroup_Chart_PreOrder.children.sort(function(blockA, blockB) {
						var blockARect = blockA.geometry(),
							blockBRect = blockB.geometry();

						var blockAArea = blockARect.size.width * blockARect.size.height,
							blockBArea = blockBRect.size.width * blockBRect.size.height;

						if (blockAArea > blockBArea) {
							return -1;
						} else if (blockAArea < blockBArea) {
							return 1;
						} else {
							return 0;
						}
					});

					while (that._drawGroup_Chart_PreOrder.children.length) {
						that._drawGroup_Chart.append(that._drawGroup_Chart_PreOrder.children[0]);
					}


					//===== Set Up Axes =====
					that._recalc_X_Axis();
					that._recalc_Y_Axis();

					that._needsRecalc = false;
					if (that._needsRedraw) {
						that._draw();
					}
				}

				that._recalcInProgress = false;
			}
		},
		_recalc_X_Axis: function() {
			var that = this;
			//== Set Up X-Axis ==
			that._drawGroup_Axes_X.clear();

			//X-Axis - Line Recalc
			that._axes.x.line.moveTo(that._VtoS_x(0), _.clampToHalfPixel(that._VtoS_y(1)))
				.lineTo(that._VtoS_x(1), _.clampToHalfPixel(that._VtoS_y(1)));
			that._drawGroup_Axes_X.append(that._axes.x.line);

			//X-Axis - Label Recalc
			that._axes.x.label = _.generateText(that._axes.x.label || that.options.axes.x.label,
				that._VtoS_x(0.5),
				that._VtoS_y(1) + (that.options.axes.x.intervals.length ? 3 * that.options.majorTicks.size : 5) + that.options.axes.x.labelSpacing,
				_.generateFontString(that.options.axisDefaults.labels.font, {
					weight: "bold"
				}),
				that.options.axisDefaults.labels.color,
				"center", "top");
			that._drawGroup_Axes_X.append(that._axes.x.label);

			//X-Axis - Tick Recalc
			that._axes.x.ticks = [];
			that._categoryLabels = {};
			var categories = that._getCategories();

			//_.fitText(rowLayout, rowRect, rowText, that.options.font.size, that.options.minFontSize, that.options.font);
			categories.forEach(function(category) {
				//Generate labels for each category
				that._categoryLabels[category] = _.generateText(
					category,
					that._DtoS_x(_.midpoint(that._bounds[that.options.fields.xLower], that._bounds[that.options.fields.xUpper]), category),
					that._VtoS_y(1) + (that.options.axes.x.intervals.length ? 3 * that.options.majorTicks.size : 5),
					that.options.axisDefaults.labels.font,
					that.options.axisDefaults.labels.color,
					"center", "top"
				);

				_.fitText(null, {
					size: {
						width: (that._DtoS_x(that._bounds[that.options.fields.xUpper], category) - that._DtoS_x(that._bounds[that.options.fields.xLower], category)) * 0.95,
						height: 1
					}
				}, that._categoryLabels[category], that.options.axisDefaults.labels.font.size, that.options.minFontSize, that.options.axisDefaults.labels.font);

				that._drawGroup_Axes_X.append(that._categoryLabels[category]);

				//Generate x-axis ticks and tick labels for each category
				that._axes.x.ticks = that._axes.x.ticks.concat(
					_.generateIntervals(that._bounds[that.options.fields.xLower],
						that._bounds[that.options.fields.xUpper],
						that.options.axes.x.intervals,
						that.options.axes.x.intervals.length > 0,
						categories.length > 0,
						that.options.axes.x.scale
					).map(function(intervalValue, i, intervals) {
						var labelValue = intervalValue;
						var tickGroup = new kDraw.Group();
						var screenPosition = that._DtoS_x(intervalValue, category);
						var tickSize = (i === 0 ? that.options.majorTicks.size : that.options.minorTicks.size),
							tickWidth = (i === 0 ? that.options.majorTicks.width : that.options.minorTicks.width);

						//Create draw group for this tick marker
						tickGroup.append(new kDraw.Path()
							.moveTo(_.clampToHalfPixel(screenPosition), _.clampToHalfPixel(that._VtoS_y(1) - tickSize / 2))
							.lineTo(_.clampToHalfPixel(screenPosition), _.clampToHalfPixel(that._VtoS_y(1) + tickSize / 2))
							.stroke("black", tickWidth));

						//Format the text for this tick marker if configured to do so
						if (that.options.axes.x.content) {
							labelValue = that.options.axes.x.content(labelValue);
						}

						//Generate kendo text for this tick marker
						var tickText = _.generateText(labelValue,
							screenPosition,
							that._VtoS_y(1) + tickSize,
							that.options.axisDefaults.labels.font,
							that.options.axisDefaults.labels.color,
							"center", "top");
						tickText.options.set("cursor", "pointer");
						tickGroup.append(tickText);

						return tickGroup;
					})
				);
			});
			that._drawGroup_Axes_X.append.apply(that._drawGroup_Axes_X, that._axes.x.ticks);
		},
		_recalc_Y_Axis: function() {
			var that = this;

			//== Set Up Y-Axis ==
			that._drawGroup_Axes_Y.clear();

			//Y-Axis - Line Recalc
			that._axes.y.line.moveTo(_.clampToHalfPixel(that._VtoS_x(0)), that._VtoS_y(0))
				.lineTo(_.clampToHalfPixel(that._VtoS_x(0)), that._VtoS_y(1));
			that._drawGroup_Axes_Y.append(that._axes.y.line);

			//Y-Axis - Label Recalc
			that._axes.y.label = _.generateText(that._axes.y.label || that.options.axes.y.label,
				that._VtoS_x(0),
				that._VtoS_y(0) - that.options.axes.y.labelSpacing,
				_.generateFontString(that.options.axisDefaults.labels.font, {
					weight: "bold"
				}),
				that.options.axisDefaults.labels.color,
				"center", "center");
			that._drawGroup_Axes_Y.append(that._axes.y.label);

			//Y-Axis - Tick Recalc
			if (!that._haveIntervalsBeenEdited) {
				that._axes.y._tickValues = _.generateScale(0.0, 1.0, that.options.axes.y.intervals);
			}

			that._axes.y.ticks = that._axes.y._tickValues.map(function(intervalValue, i) {
				var preFormattedLabelValue = Math.round(that._VtoD_y(intervalValue));
				var labelValue = preFormattedLabelValue;
				var tickGroup = new kDraw.Group();
				var screenPosition = that._VtoS_y(intervalValue);

				tickGroup._tickI = i;

				//Create draw group for this tick marker
				tickGroup.append(new kDraw.Path()
					.moveTo(_.clampToHalfPixel(that._VtoS_x(0) - that.options.minorTicks.size / 2), _.clampToHalfPixel(screenPosition))
					.lineTo(_.clampToHalfPixel(that._VtoS_x(0) + that.options.minorTicks.size / 2), _.clampToHalfPixel(screenPosition))
					.stroke("black", that.options.minorTicks.width));

				//Format the text for this tick marker if configured to do so
				if (that.options.axes.y.content) {
					labelValue = that.options.axes.y.content(preFormattedLabelValue);
				}

				//Generate kendo text for this tick marker
				var tickText = _.generateText(labelValue,
					that._VtoS_x(0) - that.options.minorTicks.size,
					screenPosition,
					that.options.axisDefaults.labels.font,
					that.options.axisDefaults.labels.color,
					"right", "center");
				tickText._isInterval = true;
				tickGroup.append(tickText);

				tickGroup.options.set("cursor", "pointer");

				return tickGroup;
			});
			that._drawGroup_Axes_Y.append.apply(that._drawGroup_Axes_Y, that._axes.y.ticks);
		},
		_rowChangeHandler: function(e) {
			var that = this;

			var rowData = e.sender;

			var needsGlobalRecalc = false;

			//If the category was changed, then the graph needs to be rescaled, affecting all other rows. This requires a full-recalc.
			if (e.field === that.options.fields.category) {
				that._recalcCategories();
				needsGlobalRecalc = true;
			}

			var rowCategories = _.getStringArray_N(rowData, that.options.fields.category, ["default"], "_category").sort();

			var blockChartData = rowData[P_DATA];

			var rowGeom = blockChartData[P_GEOM];
			var rowRect = blockChartData[P_RECT];
			var rowLayout = blockChartData[P_LAYOUT];
			var rowText = blockChartData[P_TEXT];

			if (!e.field || e.field === that.options.fields.color) {
				if (!rowData.get(that.options.fields.color)) {
					if (that.options.theme && kThemes[that.options.theme]) {
						rowData.set(that.options.fields.color, _.colorPicker(kThemes[that.options.theme].chart.seriesColors));
					} else {
						rowData.set(that.options.fields.color, _.colorPicker());
					}
				}

				rowRect.fill(rowData.get(that.options.fields.color), 0.75);

				that._needsRedraw = true;
			}

			if (!e.field || that._getGeometryFields().indexOf(e.field) > -1) {
				rowGeom.setOrigin([
					that._DtoS_x(rowData.get(that.options.fields.xLower) || 0, rowCategories),
					that._DtoS_y(rowData.get(that.options.fields.yUpper))
				]);

				rowGeom.setSize([
					Math.round(Math.abs(that._DtoS_x(rowData.get(that.options.fields.xUpper), rowCategories) - that._DtoS_x(rowData.get(that.options.fields.xLower) || 0, rowCategories))),
					Math.round(Math.abs(that._DtoS_y(rowData.get(that.options.fields.yUpper)) - that._DtoS_y(rowData.get(that.options.fields.yLower))))
				]);

				rowRect.geometry(rowGeom);

				//Reset text content, size, and orientation prior to determining if it needs to be manipulated to fit into the chart
				var textValue;
				if (typeof that.options.fields.text === "function") {
					textValue = that.options.fields.text.call(that, rowData);
				} else {
					textValue = rowData.get(that.options.fields.text);
				}
				rowText.content(textValue);
				
				_.fitText(rowLayout, rowRect, rowText, that.options.font.size, that.options.minFontSize, that.options.font/*, 0.15*/);
				
				rowText.fill(_.generateContrastingColor(rowData.get(that.options.fields.color)));

				that._needsRedraw = true;
			}

			if (that._needsRedraw) {
				if (!that._recalcInProgress) {
					that._needsRecalc = that._needsRecalc || needsGlobalRecalc;
				} else {
					that._needsRecalc = false;
				}
				that._draw();
			}
		},
		_elementClickHandler: function(e) {
			var that = this;
			_clickMod++;
			//Sooooo, kendo has a bug in which it fires click events twice for every click on a kendo.drawing.Surface, which is why this horrendous piece of code is needed
			if (kendo.version !== "2017.2.621" || _clickMod % 2) {
				if (e.element) {
					if (e.element._recordId) {
						var rowData = this.dataSource.get(e.element._recordId);
						if (rowData) {
							if (that.options.clickHandler && typeof that.options.clickHandler === "function") {
								that.options.clickHandler.apply(that, Array.prototype.slice.call(arguments).concat([rowData]));
							}
						}
					} else if (e.element._isBackground) {
						var containerSVGBoundingBox = that._innerSurface.getBoundingClientRect();
						var clickPositionX = e.originalEvent.clientX - containerSVGBoundingBox.left,
							clickPositionY = e.originalEvent.clientY - containerSVGBoundingBox.top;

						if (clickPositionX >= 0 && clickPositionX < that._VtoS_x(0) &&
							clickPositionY >= that._VtoS_y(0) && clickPositionY <= that._VtoS_y(1)) {
							
							var newYPosition_View = that._StoV_y(clickPositionY);

							//Snap the view value to the nearest interval
							newYPosition_View = _.findNearestMultiple(
								newYPosition_View,
								that.options.axes.y.snapIntervalSize,
								that._dataBoundaries.map(that._DtoV_y.bind(that))
							);

							//Cache the new position (in case the screen resizes + used for passing values to container page for external storage)
							that._axes.y._tickValues.push(newYPosition_View);

							if (that.options.tickEditedHandler && typeof that.options.tickEditedHandler === "function") {
								that.options.tickEditedHandler.apply(that, [that._axes.y._tickValues.map(that._VtoD_y.bind(that))]);
							}
							that._haveIntervalsChanged = false;
							that._haveIntervalsBeenEdited = true;

							that._recalc_Y_Axis();
						}
					}
				}
				_clickMod = 1;
			}
		},
		_elementRightClickHandler: function(e) {
			var that = this;

			if (e.target && e.target._kendoNode && e.target._kendoNode.srcElement && e.target._kendoNode.srcElement._isInterval) {
				var intervalText = e.target._kendoNode.srcElement;

				var intervalGroup = intervalText.parent;
				that._axes.y._tickValues.splice(intervalGroup._tickI, 1);

				if (that.options.tickEditedHandler && typeof that.options.tickEditedHandler === "function") {
					that.options.tickEditedHandler.apply(that, [that._axes.y._tickValues.map(that._VtoD_y.bind(that))]);
				}
				that._haveIntervalsChanged = false;
				that._haveIntervalsBeenEdited = true;

				that._recalc_Y_Axis();
			}

			e.preventDefault();
			return false;
		},
		_elementMouseUpHandler: function(e) {
			var that = this;
			_mouseUpMod++;
			if (kendo.version !== "2017.2.621" || _mouseUpMod % 2) {
				that._dragElement = null;

				if (that._haveIntervalsChanged) {
					if (that.options.tickEditedHandler && typeof that.options.tickEditedHandler === "function") {
						that.options.tickEditedHandler.apply(that, [that._axes.y._tickValues.map(that._VtoD_y.bind(that))]);
					}
					that._haveIntervalsChanged = false;
				}
			}
		},
		_dragElement: null,
		_elementMouseDownHandler: function(e) {
			var that = this;
			_mouseDownMod++;
			if (kendo.version !== "2017.2.621" || _mouseDownMod % 2) {
				if (e.element._isInterval) {
					that._dragElement = e.element.parent;
				}
			}
		},
		_elementMouseMoveHandler: function(e) {
			var that = this;
			_mouseMoveMod++;
			if (kendo.version !== "2017.2.621" || _mouseMoveMod % 2) {
				if (that._dragElement) {
					var containerSVGBoundingBox = that._innerSurface.getBoundingClientRect();
					var newYPosition = e.originalEvent.clientY - containerSVGBoundingBox.top;
					var newYPosition_View = that._StoV_y(newYPosition);

					//Clamp interval position to Y-Axis bounds
					if (newYPosition_View < 0) {
						newYPosition_View = 0;
					} else if (newYPosition_View > 1.0) {
						newYPosition_View = 1.0;
					}

					//Snap the view value to the nearest interval
					newYPosition_View = _.findNearestMultiple(
						newYPosition_View,
						that.options.axes.y.snapIntervalSize,
						that._dataBoundaries.map(that._DtoV_y.bind(that))
					);

					//Cache the new position (in case the screen resizes + used for passing values to container page for external storage)
					that._axes.y._tickValues[that._dragElement._tickI] = newYPosition_View;

					//Calculate the new screen position from the view position
					newYPosition = that._VtoS_y(newYPosition_View);

					//Calculate new label for interval
					var newDataValue = that._StoD_y(newYPosition);

					if (that.options.axes.y.content) {
						newDataValue = that.options.axes.y.content(newDataValue);
					}

					that._dragElement.children.forEach(function(childElem) {
						//Handle interval text
						if (childElem.position) {
							childElem.position().setY(newYPosition);
							childElem.content(newDataValue);
							_.applyAlignmentToText(childElem, "right", "center");
						}

						//Handle interval tick mark
						if (childElem.segments) {
							for (var i = 0; i < childElem.segments.length; i++) {
								childElem.segments[i].anchor().setY(newYPosition);
							}
						}
					});

					that._haveIntervalsBeenEdited = true;
					that._haveIntervalsChanged = true;
				}
			}
		},
		_elementMouseEnterHandler: function(e) {
			var that = this;
			_mouseEnterMod++;
			//The bug also applies to the mouseenter event. Nice!
			if (kendo.version !== "2017.2.621" || _mouseEnterMod % 2) {
				if (e.element) {
					if (e.element._recordId) {
						var rowData = that.dataSource.get(e.element._recordId);
						if (rowData) {
							that._lowerBoundValue = rowData.get(that.options.fields.yLower);

							that._lowerBoundText.content(that.options.axes.y.content(that._lowerBoundValue));
							that._lowerBoundText.visible(true);

							that._lowerBoundPath = _.generatePath(
								that._VtoS_x(1.0) + 10, that._DtoS_y(that._lowerBoundValue),
								that._VtoS_x(1.0) + that.options.hoverIntervalSpacing - 10, that._VtoS_y(1.0),
								that._lowerBoundPath
							);
							that._lowerBoundPath.visible(true);

							
							that._upperBoundValue = rowData.get(that.options.fields.yUpper);

							that._upperBoundText.content(that.options.axes.y.content(that._upperBoundValue));
							that._upperBoundText.visible(true);

							that._upperBoundPath = _.generatePath(
								that._VtoS_x(1.0) + 10, that._DtoS_y(that._upperBoundValue),
								that._VtoS_x(1.0) + that.options.hoverIntervalSpacing - 10, that._VtoS_y(0.0),
								that._upperBoundPath
							);
							that._upperBoundPath.visible(true);

							rowData[P_DATA][P_RECT].fill(_.lightenColor(rowData.get("color"), 0.15));

							that._draw();

							if (that.options.tooltip.enabled) {
								that._hoverTooltip.show($(e.originalEvent.target).attr("title", that.options.tooltip.content.call(that, rowData)));
								that._hoverTooltip.content.parent().css({
									"background-color": rowData.color,
									"color": _.generateContrastingColor(rowData.color)
								});
							}

							if (that.options.mouseEnterHandler && typeof that.options.mouseEnterHandler === "function") {
								that.options.mouseEnterHandler.apply(that, Array.prototype.slice.call(arguments).concat([rowData]));
							}
						}
					}
				}
				_mouseEnterMod = 1;
			}
		},
		_elementMouseLeaveHandler: function(e) {
			var that = this;
			_mouseLeaveMod++;
			if (kendo.version !== "2017.2.621" || _mouseLeaveMod % 2) {
				if (e.element) {
					if (e.element._recordId) {
						var rowData = that.dataSource.get(e.element._recordId);
						if (rowData) {
							that._lowerBoundText.visible(false);
							that._lowerBoundPath.visible(false);

							that._upperBoundText.visible(false);
							that._upperBoundPath.visible(false);

							rowData[P_DATA][P_RECT].fill(rowData.get("color"));

							that._draw();

							that._hoverTooltip.hide();

							if (that.options.mouseLeaveHandler && typeof that.options.mouseLeaveHandler === "function") {
								that.options.mouseLeaveHandler.apply(that, Array.prototype.slice.call(arguments).concat([rowData]));
							}
						}
					}
				}
				_mouseLeaveMod = 1;
			}
		},
		_draw: function() {
			var that = this;

			that._recalc();

			if (that._needsRedraw) {
				that._drawSurface.clear();
				that._drawSurface.draw(that._rootDrawGroup);
				that._needsRedraw = false;
			}
		},
		_initDraw: function() {
			var that = this;

			if (!that._hasDrawInit) {
				that._drawSurface = kDraw.Surface.create(that._chartContainer, {
					click: that._elementClickHandler.bind(that),
					mouseenter: that._elementMouseEnterHandler.bind(that),
					mouseleave: that._elementMouseLeaveHandler.bind(that),
					mouseup: that._elementMouseUpHandler.bind(that),
					mousedown: that._elementMouseDownHandler.bind(that),
					mousemove: that._elementMouseMoveHandler.bind(that)
				});

				that._axes = {
					x: {
						line: new kDraw.Path().stroke("black", that.options.axisDefaults.line.width)
					},
					y: {
						line: new kDraw.Path().stroke("black", that.options.axisDefaults.line.width)
					}
				};

				that._categoryLabels = {};

				that._titleText = null;
				that._lowerBoundValue = 0;
				that._lowerBoundText = null;
				that._lowerBoundPath = null;
				that._upperBoundValue = 0;
				that._upperBoundText = null;
				that._upperBoundPath = null;

				that._rootDrawGroup = new kDraw.Group();
				that._drawGroup_BG = new kDraw.Group();
				that._drawGroup_Chart = new kDraw.Group();
				that._drawGroup_Chart_PreOrder = new kDraw.Group();
				that._drawGroup_Axes_X = new kDraw.Group();
				that._drawGroup_Axes_Y = new kDraw.Group();
				that._drawGroup_Text = new kDraw.Group();

				that._rootDrawGroup.append(
					that._drawGroup_BG,
					that._drawGroup_Chart,
					that._drawGroup_Axes_X,
					that._drawGroup_Axes_Y,
					that._drawGroup_Text
				);

				that._drawSurface.draw(that._rootDrawGroup);

				that._hasDrawInit = true;
			}
		},
		_recalcCategories: function() {
			var that = this;

			that._allCategoriesMap = {};

			that.dataSource.data().forEach(function(dataRow) {
				_.getStringArray_N(dataRow, that.options.fields.category, ["default"], "_category").forEach(function(category) {
					that._allCategoriesMap[category] = true;
				});
			});
		},
		_getCategories: function() {
			return Object.keys(this._allCategoriesMap).sort();
		},
		_calcDataBoundaries: function() {
			var that = this;

			var _dataBoundaries = {};

			that.dataSource.data().forEach(function(dataRow) {
				_dataBoundaries[dataRow.get(that.options.fields.yLower)] = true;
				_dataBoundaries[dataRow.get(that.options.fields.yUpper)] = true;
			});

			that._dataBoundaries = Object.keys(_dataBoundaries);
		},
		_initDOM: function() {
			var that = this;

			if (!that._hasDOMInit) {
				that.element.addClass("k-widget k-treemap");

				that._innerSurface = that._chartContainer.querySelectorAll("svg");
				that._innerSurface = that._innerSurface && (that._innerSurface.length && that._innerSurface[0]);

				that._innerSurface.addEventListener("contextmenu", that._elementRightClickHandler.bind(that));

				that._$hoverTooltip = $("<div/>").appendTo(that._chartContainer).kendoTooltip({
					width: 120,
					position: "bottom"
				});

				that._hoverTooltip = that._$hoverTooltip.data("kendoTooltip");

				if (typeof that.options.size === "string" && that.options.size === "fit") {
					that._fitMode = true;

					that._innerSurface.style.width = "100%";
					that._innerSurface.style.height = "100%";

					var svgBounds = that._innerSurface.getBoundingClientRect();
					that._outerWidth = svgBounds.width;
					that._outerHeight = svgBounds.height;
				} else {
					that._outerWidth = that.options.width;
					that._outerHeight = that.options.height;
				}

				that._aspectRatio = that._outerWidth / that._outerHeight;

				that._innerWidth = that._outerWidth - (that.options.innerPadding.left + that.options.innerPadding.right);
				that._innerHeight = that._outerHeight - (that.options.innerPadding.top + that.options.innerPadding.bottom);

				that._hasDOMInit = true;
			}
		},
		_initResizeHandler: function() {
			var that = this;

			if (!that._hasInitResize) {
				var resizeHandlerWaiting = false;
				window.addEventListener("resize", function() {
					if (!resizeHandlerWaiting) {
						resizeHandlerWaiting = true;

						setTimeout(function() {

							var newWidth = that._outerWidth, newHeight = that._outerHeight;

							if (that._fitMode) {
								var svgBounds = that._innerSurface.getBoundingClientRect();
								newWidth = svgBounds.width;
								newHeight = svgBounds.height;
							} else {
								var wWidth = window.innerWidth,
									wHeight = window.innerHeight;

								if (wWidth < newWidth || wHeight < newHeight) {
									if (newWidth - wWidth > newHeight - wHeight) {
										newWidth = wWidth;
										newHeight = wWidth / that._aspectRatio;
									} else {
										newHeight = wHeight;
										newWidth = wHeight * that._aspectRatio;
									}
								} else {
									if (wWidth - newWidth < wHeight - newHeight) {
										newWidth = Math.min(wWidth, that.options.size.width);
										newHeight = newWidth / that._aspectRatio;
									} else {
										newHeight = Math.min(wHeight, that.options.height);
										newWidth = newHeight * that._aspectRatio;
									}
								}
							}
							
							that._recalc();
							that._draw();

							that._setSize(newWidth, newHeight);

							resizeHandlerWaiting = false;
						}, 1000/15);
					}
				});

				window.dispatchEvent(new Event("resize"));

				that._hasInitResize = true;
			}
		},
		destroy: function() {
			var that = this;
			Widget.fn.destroy.call(that);
			that.element.off(widgetJQName);
			kendo.destroy(that.element);
		},
		resize: function() {
			var that = this;
			var rescaleAmount = that._getRescaleAmount();
			that._rescaleApplied = true;
			that._setSize(that._outerWidth * rescaleAmount.x, that._outerHeight * rescaleAmount.y);
		},
		setScale: function(scale, compressionStrength){
			var that = this;
			that.options.axes.y.scale = scale;
			if (scale === "logarithmic") {
				that.options.axes.y.compressionStrength = compressionStrength || that.options.axes.y.compressionStrength || Math.E;
				that.options.axes.y.range = [1, Math.pow(10, that.options.axes.y.compressionStrength)];
			}
			that.refresh();
		},
		setIntervals: function(newIntervalValues) {
			var that = this;

			that._$ready.then(function() {
				if (newIntervalValues && newIntervalValues.length) {
					that._axes.y._tickValues = newIntervalValues.map(that._DtoV_y.bind(that));
					that._haveIntervalsBeenEdited = true;

					that.refresh();
				}
			});
		},
		setBounds: function(xLower, xUpper, yLower, yUpper) {
			var that = this;
			that._boundsOverride = kendo.deepExtend(
				that._boundsOverride,
				{
					xLower: xLower,
					xUpper: xUpper,
					yLower: yLower,
					yUpper: yUpper
				}
			);

			that.refresh();
		},
		setBound_xLower: function(val) {
			this.setBounds.call(this, val);
		},
		setBound_xUpper: function(val) {
			this.setBounds.call(this, null, val);
		},
		setBound_yLower: function(val) {
			this.setBounds.call(this, null, null, val);
		},
		setBound_yUpper: function(val) {
			this.setBounds.call(this, null, null, null, val);
		},
		_setSize: function(width, height) {
			var that = this;

			if (that._fitMode) {
				that._outerWidth = width;
				that._outerHeight = height;
			} else {
				var rescaleAmount = that._getRescaleAmount();

				var minWidth = rescaleAmount.x * that._outerWidth,
					minHeight = rescaleAmount.y * that._outerWidth;

				if (width < minWidth || height < minHeight) {
					if (width < minWidth) {
						width = minWidth;
						height = width / that._aspectRatio;
					} else {
						height = minHeight;
						width = height * that._aspectRatio;
					}
				}

				that._outerWidth = width >= minWidth ? width : minWidth;
				that._outerHeight = height >= minHeight ? height : minHeight;

				that._innerSurface.style.width = that._outerWidth + "px";
				that._innerSurface.style.height = that._outerHeight + "px";

				that._chartContainer.style.overflow = "auto";
			}

			that._innerWidth = that._outerWidth - (that.options.innerPadding.left + that.options.innerPadding.right);
			that._innerHeight = that._outerHeight - (that.options.innerPadding.top + that.options.innerPadding.bottom);

			that._needsRecalc = true;
			that._draw();
		},
		_getRescaleAmount: function() {
			var that = this;

			var minWidth, minHeight;
			var rowRescaleHandler;
			that.dataSource.data().forEach(rowRescaleHandler = function(rowData) {
				if (rowData.get(that.options.fields.xUpper) - rowData.get(that.options.fields.xLower) === 0 ||
					rowData.get(that.options.fields.yUpper) - rowData.get(that.options.fields.yLower) === 0) {
					//Skip the current iteration if the data is invalid. Keeps the graph from scaling out of wack
					return;
				}

				var bbox = rowData[P_DATA][P_RECT].bbox();
				minWidth = minWidth || bbox.size.width;
				minHeight = minHeight || bbox.size.height;

				minWidth = Math.min(bbox.size.width, minWidth);
				minHeight = Math.min(bbox.size.height, minHeight);

				if (rowData.get(that.options.fields.children)) {
					rowData.get(that.options.fields.children).forEach(rowRescaleHandler);
				}
			});

			return {
				x: minWidth ? (that.options.minDims.x / minWidth) : 1,
				y: minHeight ? (that.options.minDims.y / minHeight) : 1
			};
		},
		getImageDataURI: function(sizeScalar) {
			var that = this;
			
			sizeScalar = sizeScalar || 1;

			var rootDrawBBox = that._rootDrawGroup.bbox();
			that._rootDrawGroup.transform(kGeom.transform().scale(2, 2));
			var dataImageURI = kDraw.exportImage(that._rootDrawGroup, {width: (sizeScalar * rootDrawBBox.size.width + "px"), height: (sizeScalar * rootDrawBBox.size.height) + "px"});
			that._rootDrawGroup.transform(kGeom.transform().scale(1, 1));
			return dataImageURI;
		},

		//==== Data Mapping Functions for 3 Spaces Used by Visualization ====
		_applyScaleTransform: function(val, axis) {
			var that = this;
			switch (that.options.axes[axis].scale) {
				case "logarithmic":
					var scaleSize = that.options.axes[axis].range[1] - that.options.axes[axis].range[0];
					return Math.log(val * scaleSize + that.options.axes[axis].range[0]) / Math.log(10) / that.options.axes[axis].compressionStrength;
				case "cubic": 
					return Math.pow(val, 3);
				default:
					return val;
			}
		},

		_applyScaleTransform_x: function(val) {
			return this._applyScaleTransform(val, "x");
		},

		_applyScaleTransform_y: function(val) {
			return this._applyScaleTransform(val, "y");
		},

		_invertScaleTransform: function(val, axis) {
			var that = this;
			switch (that.options.axes[axis].scale) {
				case "logarithmic":
					var scaleSize = that.options.axes[axis].range[1] - that.options.axes[axis].range[0];
					return (Math.pow(10, that.options.axes[axis].compressionStrength * val) - that.options.axes[axis].range[0]) / scaleSize;
				case "cubic":
					return Math.cbrt(val);
				default:
					return val;
			}
		},

		_invertScaleTransform_x: function(val) {
			return this._invertScaleTransform(val, "x");
		},

		_invertScaleTransform_y: function(val) {
			return this._invertScaleTransform(val, "y");
		},


		// ==== DATA -> VIEW ====
		_dataToViewSpace: function(point, category) {
			var that = this;
			return [
				that._dataToViewSpace_x.call(that, point[0], category), 
				that._dataToViewSpace_y.call(that, point[1], category)
			];
		},
		_DtoV: function(point, category) {
			return this._dataToViewSpace.call(this, point, category);
		},
		_dataToViewSpace_x: function(xVal, category) {
			var that = this;

			var viewSpace_x = Math.min((xVal - that._bounds[that.options.fields.xLower]) / 
				(that._bounds[that.options.fields.xUpper] - that._bounds[that.options.fields.xLower]),
				1
			);

			if (category) {
				category = Array.isArray(category) ? category : [category];
				var categories = that._getCategories();
				var categorySize = category.length / categories.length;
				var categoryOffset = Math.max(categories.findIndex(function(cat) {
					return cat === category[0];
				}), 0);

				return categorySize * viewSpace_x + categoryOffset * categorySize;
			} else {
				return viewSpace_x;
			}
		},
		_DtoV_x: function(xVal, category) {
			return this._dataToViewSpace_x.call(this, xVal, category);
		},
		_dataToViewSpace_y: function(yVal) {
			var that = this;
			//First step, normalize the input value to a <0:1, 0:1> space based on the data upper and lower bounds
			var initialTransform = (yVal - that._bounds[that.options.fields.yLower]) / (that._bounds[that.options.fields.yUpper] - that._bounds[that.options.fields.yLower]);
			
			//Clamp the output value to 1 as a max, just in case
			var valToScale = Math.min(initialTransform,1);

			//Apply the appropriate transformation based on the block chart's configuration
			var scaledTransform = that._applyScaleTransform_y(valToScale);

			//Clamp the output value to 0 as a min, just in case
			var pointInSpace = Math.max(scaledTransform,0);

			//Invert the output value (y-flip => Y view/screen coordinates start from the top left, while data starts from the bottom left)
			return 1 - pointInSpace;
		},
		_DtoV_y: function(yVal) {
			return this._dataToViewSpace_y.call(this, yVal);
		},


		// ==== DATA <- VIEW ====
		_viewToDataSpace_y: function(yVal) {
			var that = this;

			//View space is inverted, so the input coordinate needs to be inverted before being mapped to data space
			yVal = 1 - yVal;

			//Reverse the scale factor for this axis
			yVal = that._invertScaleTransform_y(yVal);

			//Use a linear scale and transformation to transform the input coordinate into data space
			yVal = yVal * (that._bounds[that.options.fields.yUpper] - that._bounds[that.options.fields.yLower]) + that._bounds[that.options.fields.yLower];

			return yVal;
		},
		_VtoD_y: function(yVal) {
			return this._viewToDataSpace_y.call(this, yVal);
		},


		// ==== OUTER VIEW -> SCREEN ====
		_outerViewToScreenSpace: function(point) {
			var that = this;
			return [
				that._outerViewToScreenSpace_x.call(that, point[0]),
				that._outerViewToScreenSpace_y.call(that, point[1])
			];
		},
		_OVtoS: function(point) {
			return _outerViewToScreenSpace.call(this, point);
		},
		_outerViewToScreenSpace_x: function(xVal) {
			return xVal * this._outerWidth;
		},
		_OVtoS_x: function(xVal) {
			return this._outerViewToScreenSpace_x.call(this, xVal);
		},
		_outerViewToScreenSpace_y: function(yVal) {
			return yVal * this._outerHeight;
		},
		_OVtoS_y: function(yVal) {
			return this._outerViewToScreenSpace_y.call(this, yVal);
		},


		// ==== VIEW -> SCREEN ====
		_viewToScreenSpace: function(point) {
			var that = this;
			return [
				that._viewToScreenSpace_x.call(that, point[0]), 
				that._viewToScreenSpace_y.call(that, point[1])
			];
		},
		_VtoS: function(point) {
			return this._viewToScreenSpace.call(this, point);
		},
		_viewToScreenSpace_x: function(xVal) {
			var that = this;
			return that.options.innerPadding.left + xVal * that._innerWidth;
		},
		_VtoS_x: function(xVal) {
			return this._viewToScreenSpace_x.call(this, xVal);
		},
		_viewToScreenSpace_y: function(yVal) {
			var that = this;
			return that.options.innerPadding.top + yVal * that._innerHeight;
		},
		_VtoS_y: function(yVal) {
			return this._viewToScreenSpace_y.call(this, yVal);
		},


		// ==== VIEW <- SCREEN ====
		_screenToViewSpace: function(point) {
			var that = this;
			return [
				that._screenToViewSpace_x.call(that, point[0]),
				that._screenToViewSpace_y.call(that, point[1])
			];
		},
		_StoV: function(point) {
			return this._screenToViewSpace.call(this, point);
		},
		_screenToViewSpace_x: function(xVal) {
			var that = this;
			return (xVal - that.options.innerPadding.left) / that._innerWidth;
		},
		_StoV_x: function(xVal) {
			return this._screenToViewSpace_x.call(this, xVal);
		},
		_screenToViewSpace_y: function(yVal) {
			var that = this;
			return (yVal - that.options.innerPadding.top) / that._innerHeight;
		},
		_StoV_y: function(yVal) {
			return this._screenToViewSpace_y.call(this, yVal);
		},

		bind: function(eventName, handler) {
			this._$evts.on(eventName, handler);
			return this;
		},


		// ==== DATA -> VIEW -> SCREEN ====
		_dataToScreenSpace: function(point, category) {
			var that = this;
			return [
				that._dataToScreenSpace_x.call(that, point[0], category), 
				that._dataToScreenSpace_y.call(that, point[1], category)
			];
		},
		_DtoS: function(point, category) {
			return this._dataToScreenSpace.call(this, point, category);
		},
		_dataToScreenSpace_x: function(xVal, category) {
			var that = this;
			return that._viewToScreenSpace_x.call(that, that._dataToViewSpace_x.call(that, xVal, category));
		},
		_DtoS_x: function(xVal, category) {
			return this._dataToScreenSpace_x.call(this, xVal, category);
		},
		_dataToScreenSpace_y: function(yVal) {
			var that = this;
			return that._viewToScreenSpace_y.call(that, that._dataToViewSpace_y.call(that, yVal));
		},
		_DtoS_y: function(yVal) {
			return this._dataToScreenSpace_y.call(this, yVal);
		},


		// ==== DATA <- VIEW <- SCREEN ====
		_screenToDataSpace_y: function(yVal) {
			return this._viewToDataSpace_y.call(this, this._screenToViewSpace_y.call(this, yVal));
		},
		_StoD_y: function(yVal) {
			return this._screenToDataSpace_y.call(this, yVal);
		},

		//==== Widget Config ====
		_$evts: $({}),
		events: {
			"E_CHANGEBOUND": E_CHANGEBOUND,
			"E_DATABINDING": E_DATABINDING,
			"E_DATABOUND": E_DATABOUND
		},
		options: {
			name: widgetName,
			autoBind: true,
			fields: {
				xLower: "xLower",
				xUpper: "xUpper",
				yLower: "yLower",
				yUpper: "yUpper",
				color: "color",
				text: "text",
				textAlignH: "textAlignH",
				textAlignV: "textAlignV",
				children: "children",
				category: "category"
			},
			tooltip: {
				enabled: true,
				content: function(rowData) {
					return rowData.get(this.options.fields.text);
				}
			},
			clickHandler: function(e, rowData) {

			},
			mouseEnterHandler: function(e, rowData) {

			},
			mouseLeaveHandler: function(e, rowData) {

			},
			tickEditedHandler: function(e, tickData) {

			},
			title: {
				text: "Block Chart",
				font: {
					size: 20,
					family: "\"Courier New\", Courier, \"Lucida Sans Typewriter\", \"Lucida Typewriter\", monospace",
					//family: "Roboto Mono",
					style: "bold"
				}
			},
			width: 800,
			height: 600,
			size: {
				width: 800,
				height: 600
			},
			backgroundColor: "#FFFFFF",
			innerPadding: {
				left: 100,
				top: 100,
				right: 150,
				bottom: 100
			},
			hoverIntervalSpacing: 60,
			minDims: {
				x: 10,
				y: 10
			},
			minFontSize: 7,
			strokeSize: 1,
			font: {
				size: 14,
				family: "\"Courier New\", Courier, \"Lucida Sans Typewriter\", \"Lucida Typewriter\", monospace",
				//family: "Roboto Mono",
				//style: "bold"
			},
			axisDefaults: {
				labels: {
					font: {
						size: 10,
						family: "\"Courier New\", Courier, \"Lucida Sans Typewriter\", \"Lucida Typewriter\", monospace"
						//family: "Roboto Mono"
					}
				},
				line: {
					width: 1
				}
			},
			axes: {
				x: {
					label: "X",
					intervals: 5,
					labelSpacing: 20,
					content: function(val) {
						return val.toFixed(2) + "%";
					}
				},
				y: {
					label: "Y",
					intervals: 20,
					labelSpacing: 20,
					snapIntervalSize: 1.0 / 15,
					content: function(val) {
                        if (val >= 1000000000000) {
                            return (val / 1000000000000).toFixed(2) + "T";
                        } else if (val >= 1000000000) {
                            return (val / 1000000000).toFixed(2) + "B";
                        } else if (val >= 1000000) {
                            return (val / 1000000).toFixed(2) + "M";
                        } else {
                            return parseFloat(val.toFixed(2));
                        }
                        return val;
					}
				}
			}
		},
		props: {
			data: P_DATA,
			geometry: P_GEOM,
			rectangle: P_RECT,
			layout: P_LAYOUT,
			text: P_TEXT
		},
		_initTheme: function(options) {
			var that = this;

			//If a theme isn't explicitly defined, attempt to determine which theme stylesheet is loaded
			if (!that.options.theme) {
				that.options.theme = _.getCurrentTheme();
			}

			var baseOptions = kendo.dataviz.chartBaseTheme();

			var extendedOptions = kendo.deepExtend({}, baseOptions, {
				majorTicks: kendo.dataviz.LinearScale.prototype.options.majorTicks,
				minorTicks: kendo.dataviz.LinearScale.prototype.options.minorTicks
			});

			var themes = kThemes || {},
				themeName = ((options || {}).theme || "").toLowerCase(),
				defaultThemeOptions = (themes[themeName] || {}),
				themeOptions = kendo.deepExtend(extendedOptions, defaultThemeOptions.chart || {}, defaultThemeOptions.treeMap || {});

			that.options = kendo.deepExtend({}, themeOptions, options);
		},
		setOptions: function(options) {
			var that = this;

			if (typeof options.innerPadding !== "object") {
				var originalPadding = options.innerPadding;
				options.innerPadding = {
					left: originalPadding,
					top: originalPadding,
					right: 1.5 * originalPadding,
					bottom: originalPadding
				};
			}

			var dataSource = options.dataSource;
			options.dataSource = undefined;
			that._originalOptions = kendo.deepExtend(that._originalOptions, options);
			that.options = kendo.deepExtend({}, that._originalOptions);
			that._initTheme(that.options);

			that.setScale(that.options.axes.y.scale, that.options.axes.y.compressionStrength);

			Widget.fn._setEvents.call(that, options);
			that._dataSource();
		},
		_getGeometryFields: function() {
			var that = this;
			return [
				that.options.fields.xLower, that.options.fields.xUpper,
				that.options.fields.yLower, that.options.fields.yUpper
			];
		}
	});

	kendo.ui.plugin(BlockChart);
})(jQuery);